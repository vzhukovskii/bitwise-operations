# Битовые операции
#### Операции с целыми числами

* Установка _n_-ого бита
`x | (1 << n)`
---
* Обнуление _n_-ого бита
`x & ~(1 << n)`
---
* Переключение _n_-ого бита
`x ^ (1 << n)`
---
* Округление до следующей степени двойки

```
int v;
v--;
v |= v >> 1;
v |= v >> 2;
v |= v >> 4;
v |= v >> 8;
v |= v >> 16;
v++;
```
---
* Получение максимального целого
```
int maxInt = ~(1 << 31);
int maxInt = (1 << 31) - 1;
int maxInt = (1 << -1) - 1;
```
---
* Получение минимального целого
```
int minInt = 1 << 31;
int minInt = 1 << -1;
```
---
* Получение макисмального _long_
`long maxLong = ((long)1 << 127) - 1;`
---
* Умножение на 2
`n << 1;`
---
* Деление на 2
`n >> 1;`
---
* Умножение на _m_-тую степень 2
`n << m;`
---
* Деление на _m_-тую степень 2
`n >> m;`
---
* Проверка на равенство
`(a^b) == 0; // a == b`
---
* Проверка на чётность
`(n & 1) == 1;`
---
* Обмен значениями
```
a ^= b;
b ^= a;
a ^= b;
```
---
* Модуль
```
//version 1
x < 0 ? -x : x;
 
//version 2
(x ^ (x >> 31)) - (x >> 31);
```
---
* Максимум двух чисел
`b & ((a-b) >> 31) | a & (~(a-b) >> 31);`
---
* Минимум двух чисел
`a & ((a-b) >> 31) | b & (~(a-b) >> 31);`
---
* Проверка на одинаковый знак
`(x ^ y) >= 0;`
---
* Смена знака
```
i = ~i + 1; // or
i = (i ^ -1) + 1; // i = -i
```
---
Вычисление 2^_n_
`2 << (n-1);`
---
* Проверка на степень 2
`n > 0 && (n & (n - 1)) == 0;`
---
* Остаток от деления 2^_n_ на _m_
`m & (n - 1);`
---
* Среднее арифметическое
```
(x + y) >> 1;
((x ^ y) >> 1) + (x & y);
```
---
* Получение _m_-ого бита _n_ (справа налево)
`(n >> (m-1)) & 1;`
---
* Установка _m_-ого бита _n_ (справа налево)
`n & ~(1 << (m-1));`
---
Проверка _n_-ого бита
```
if (x & (1<<n)) {
  n-th bit is set
}
else {
  n-th bit is not set
}
```
---
* Выделение самой правой 1
`x & (-x)`
---
* Выделение самого правого 0
`~x & (x+1)`
---
* Смена самого правого 0 на 1
`x | (x+1)`
---
* _n_+1
`-~n`
---
* _n_-1
`~-n`
---
* if (x\==a) x=b; if (x\==b) x=a;
`x = a ^ b ^ x;`

#### Операции со строками

* Преобразование буквы в строчную
_OR by space => (x | ' ')_
_Result is always lowercase even if letter is already lowercase_
`eg. ('a' | ' ') => 'a' ; ('A' | ' ') => 'a'`
---
* Преобразование буквы в заглавную
_AND by underline => (x & '\_')_
_Result is always uppercase even if letter is already uppercase_
`eg. ('a' & '_') => 'A' ; ('A' & '_') => 'A'`
---
* Смена вида буквы
_XOR by space => (x ^ ' ')_
`eg. ('a' ^ ' ') => 'A' ; ('A' ^ ' ') => 'a'`
---
* Номер буквы в алфавите
_AND by chr(31)/binary('11111')/(hex('1F') => (x & "\x1F")_
_Result is in 1..26 range, letter case is not important_
`eg. ('a' & "\x1F") => 1 ; ('B' & "\x1F") => 2`
---
* Номер заглавной буквы в алфавите
_AND by ? => (x & '?') or XOR by @ => (x ^ '@')_
`eg. ('C' & '?') => 3 ; ('Z' ^ '@') => 26`
---
* Номер строчной буквы в алфавите
_XOR by backtick/chr(96)/binary('1100000')/hex('60') => (x ^ '\`')_
```
eg. ('d' ^ '`') => 4 ; ('x' ^ '`') => 25
```